{"version":3,"file":"options.bundle.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7qEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./src/jq.js","webpack:///./src/json_var_resolver.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/options.js"],"sourcesContent":["// https://github.com/mwh/jqjs/blob/f0f33bbcce4a3c072f099efc1a2c9c149d4db4c7/jq.js\n// jqjs - jq JSON query language in JavaScript\n// Copyright (C) 2018-2023 Michael Homer\n/*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nfunction compile(prog) {\n    let filter = parse(tokenise(prog).tokens)\n    const ret = input => filter.node.apply(input, {\n        userFuncs: {},\n        userFuncArgs: {},\n        variables: {}\n    })\n    ret.filter = filter\n    ret.trace = (input) => {\n        let dest = []\n        filter.node.trace(input, {\n            userFuncs: {},\n            userFuncArgs: {},\n            variables: {}\n        }, dest)\n        return {\n            node: null,\n            output: input,\n            next: dest,\n        }\n    }\n    return ret\n}\n\nfunction compileNode(prog) {\n    return parse(tokenise(prog).tokens).node\n}\n\nfunction isAlpha(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_'\n}\n\nfunction isDigit(c) {\n    return (c >= '0' && c <= '9')\n}\n\nfunction prettyPrint(val, indent='', step='    ', LF='\\n') {\n    let SP = step ? ' ' : ''\n    if (typeof val == 'undefined')\n        return val\n    if (val === null) {\n        return 'null'\n    } else if (val instanceof Array) {\n        let ret = '['\n        let first = true\n        for (let v of Object.values(val)) {\n            ret += (first ? '' : ',') + LF + indent + step +\n                prettyPrint(v, indent + step, step, LF)\n            first = false\n        }\n        ret += LF + indent + ']'\n        return ret\n    } else if (typeof val == 'object') {\n        let ret = '{'\n        let first = true\n        for (let k of Object.keys(val)) {\n            ret += (first ? '' : ',') + LF + indent + step +\n                '\"' + k + '\":' +SP+ prettyPrint(val[k], indent + step, step, LF)\n            first = false\n        }\n        ret += LF + indent + '}'\n        return ret\n    } else if (typeof val == 'string') {\n        return '\"' + escapeString(val) + '\"'\n    } else if (typeof val == 'number') {\n        return '' + val\n    } else if (typeof val == 'boolean') {\n        return val ? 'true' : 'false'\n    }\n}\n\nfunction escapeString(s) {\n    s = s.replace(/\\\\/g, '\\\\\\\\')\n    s = s.replace(/\"/g, '\\\\\"')\n    s = s.replace(/\\n/g, '\\\\n')\n    s = s.replace(/[\\x00-\\x1f]/g,\n        x => '\\\\u00' + x.charCodeAt(0).toString(16).padStart(2, '0'))\n    return s\n}\n\nfunction* zip(a, b) {\n    let aa = a[Symbol.iterator]()\n    let bb = b[Symbol.iterator]()\n    let v1 = aa.next()\n    let v2 = bb.next()\n    while (!v1.done && !v2.done) {\n        yield [v1.value, v2.value]\n        v1 = aa.next()\n        v2 = bb.next()\n    }\n}\n\n// Implements the jq ordering algorithm, which is terrible.\nfunction compareValues(a, b) {\n    let at = nameType(a)\n    let bt = nameType(b)\n    if (at != bt) {\n        return compareValues.typeOrder.indexOf(at) -\n            compareValues.typeOrder.indexOf(bt)\n    }\n    if (at == 'boolean') {\n        if (a && !b) return 1\n        if (!a && b) return -1\n    } else if (at == 'number') {\n        return a - b\n    } else if (at == 'string') {\n        if (a < b) return -1\n        if (b < a) return 1\n    } else if (at == 'array') {\n        for (let i = 0; i < a.length; i++) {\n            let v1 = a[i]\n            let v2 = b[i]\n            if (typeof v1 == 'undefined' && typeof v2 != 'undefined')\n                return -1\n            else if (typeof v1 != 'undefined' && typeof v2 == 'undefined')\n                return 1\n            else if (typeof v1 == 'undefined') return 0\n            let c = compareValues(v1, v2)\n            if (c != 0) return c\n        }\n        return 0\n    } else if (at == 'object') {\n        let ka = Object.keys(a).sort()\n        let kb = Object.keys(b).sort()\n        let c = compareValues(ka, kb)\n        if (c) return c\n        for (let k of ka) {\n            c = compareValues(a[k], b[k])\n            if (c) return c\n        }\n    }\n    return 0\n}\ncompareValues.typeOrder = ['null', 'boolean', 'number', 'string',\n                           'array', 'object']\n\n// Create a function from a program string.\n//\n// params is an array of parameter names\n// body is a jq program as a string, which may use the parameters\n//\n// For example:\n//     makeFunc(['f'], '[.[] | f]')\n// defines the map function.\nfunction makeFunc(params, body, pathFunc=false) {\n    let c = compileNode(body)\n    let f = (x, conf) => c.apply(x, conf)\n    if (pathFunc)\n        f = (x, conf) => c.paths(x, conf)\n    return function*(input, conf, args) {\n        let origArgs = conf.userFuncArgs\n        conf.userFuncArgs = Object.create(origArgs)\n        for (let i = 0; i < params.length; i++) {\n            let pn = params[i]\n            let pv = args[i]\n            conf.userFuncArgs[pn + '/0'] = pv\n        }\n        yield* f(input, conf)\n        conf.userFuncArgs = origArgs\n    }\n}\n\n// Define and save a function that is shorthand for a longer expression\n//\n// name is the name of the function\n// params is an array of parameters, or a string of one-character names\n// body is a jq program as a string\nfunction defineShorthandFunction(name, params, body) {\n    let fname = name + '/' + params.length\n    functions[fname] = makeFunc(params, body)\n    functions[fname].params = Array.prototype.map.call(params, label => ({label, mode: 'defer'}))\n    functions[fname + '-paths'] = makeFunc(params, body, true)\n}\n\n// Recursive-descent parser for JQ query language\n\n// Split input program into tokens. Tokens are:\n// quote, number, identifier-index, dot-square, dot, left-square,\n// right-square, left-paren, right-paren, pipe, comma,\n// identifier, colon, left-brace, right-brace, semicolon, at,\n// variable, as, reduce, foreach, def, import, include, question\n// if, then, else, end, elif\nfunction tokenise(str, startAt=0, parenDepth) {\n    let ret = []\n    function error(msg) {\n        throw msg;\n    }\n    let i\n    toplevel: for (i = startAt; i < str.length; i++) {\n        let location = i\n        let c = str[i]\n        if (c == ' ')\n            continue;\n        if (c == '\"' || c == \"'\") {\n            let st = c\n            let tok = \"\"\n            let escaped = false\n            let uniEsc\n            let cu = 0\n            for (i++; i < str.length; i++) {\n                if (uniEsc) {\n                    uniEsc--\n                    cu *= 16\n                    cu += Number.parseInt(str[i], 16)\n                    if (uniEsc == 0) {\n                        tok += String.fromCharCode(cu)\n                        cu = 0\n                    }\n                } else if (escaped) {\n                    let q = str[i]\n                    if (q == '\"' || q == \"'\") tok += q\n                    else if (q == 'n') tok += '\\n'\n                    else if (q == 't') tok += '\\t'\n                    else if (q == 'r') tok += '\\r'\n                    else if (q == 'b') tok += '\\b'\n                    else if (q == 'f') tok += '\\f'\n                    else if (q == '/') tok += '/'\n                    else if (q == '\\\\')tok += '\\\\'\n                    else if (q == 'u') uniEsc = 4\n                    else if (q == '(') {\n                        // Interpolation\n                        let r = tokenise(str, i + 1, 0)\n                        ret.push({type: 'quote-interp', value: tok, location})\n                        tok = ''\n                        ret = ret.concat(r.tokens)\n                        i = r.i\n                    }\n                    else throw \"invalid escape \" + q\n                    escaped = false\n                } else if (str[i] == '\\\\') {\n                    escaped = true\n                } else if (str[i] == st) {\n                    ret.push({type: 'quote', value: tok, location})\n                    continue toplevel\n                } else {\n                    escaped = false\n                    tok += str[i]\n                }\n            }\n            error(\"unterminated string literal\")\n        } else if (isDigit(c)) {\n            let tok = ''\n            while (isDigit(str[i]) || str[i] == '.')\n                tok += str[i++]\n            ret.push({type: 'number', value: Number.parseFloat(tok), location})\n                i--\n        } else if (c == '.') {\n            let d = str[i+1]\n            if (isAlpha(d)) {\n                i++\n                let tok = ''\n                while (isAlpha(str[i]) || isDigit(str[i]))\n                    tok += str[i++]\n                ret.push({type: 'identifier-index', value: tok, location})\n                i--\n            } else if (d == '[') {\n                i++\n                ret.push({type: 'dot-square', location})\n            } else if (d == '.') {\n                i++\n                ret.push({type: 'dot-dot', location})\n            } else {\n                ret.push({type: 'dot', location})\n            }\n        } else if (c == '$') {\n            let d = str[i+1]\n            i++\n            let tok = ''\n            while (isAlpha(str[i]) || isDigit(str[i])) {\n                tok += str[i]\n                i++\n            }\n            ret.push({type: 'variable', name: tok, location})\n            i--\n        } else if (c == '[') {\n            ret.push({type: 'left-square', location})\n        } else if (c == ']') {\n            ret.push({type: 'right-square', location})\n        } else if (c == '(') {\n            ret.push({type: 'left-paren', location})\n            parenDepth++\n        } else if (c == ')') {\n            ret.push({type: 'right-paren', location})\n            parenDepth--\n            if (parenDepth < 0)\n                return {tokens: ret, i}\n        } else if (c == '{') {\n            ret.push({type: 'left-brace', location})\n        } else if (c == '}') {\n            ret.push({type: 'right-brace', location})\n        } else if (c == ',') {\n            ret.push({type: 'comma', location})\n        } else if (c == ';') {\n            ret.push({type: 'semicolon', location})\n        } else if (c == '@') {\n            ret.push({type: 'at', location})\n        } else if (c == '?') {\n            ret.push({type: 'question', location})\n        } else if (c == '|') {\n            let d = str[i+1]\n            if (d == '=') {\n                ret.push({type: 'pipe-equals', location})\n                i++\n            } else\n                ret.push({type: 'pipe', location})\n        // Infix operators\n        } else if (c == '+' || c == '*' || c == '-' || c == '/' || c == '%'\n                || c == '<' || c == '>') {\n            if (c == '/' && str[i+1] == '/') {\n                c = '//'\n                i++\n            }\n            if (str[i+1] == '=') {\n                if (c == '<' || c == '>')\n                    ret.push({type: 'op', op: c + '=', location})\n                else\n                    ret.push({type: 'op-equals', op: c, location})\n                i++\n            } else\n                ret.push({type: 'op', op: c})\n        } else if (c == '=') {\n            if (str[i + 1] != '=')\n                throw 'plain assignment = is not supported'\n            i++\n            ret.push({type: 'op', op: '==', location})\n        } else if (c == '!') {\n            if (str[i + 1] != '=')\n                throw 'unexpected ! at ' + location\n            i++\n            ret.push({type: 'op', op: '!=', location})\n        } else if (isAlpha(c)) {\n            let tok = ''\n            while (isAlpha(str[i]) || isDigit(str[i]) || str[i] == '_')\n                tok += str[i++]\n            if (tok == 'as' || tok == 'reduce' || tok == 'foreach'\n                    || tok == 'import' || tok == 'include' || tok == 'def'\n                    || tok == 'if' || tok == 'then' || tok == 'else'\n                    || tok == 'end' || tok == 'elif') {\n                ret.push({type: tok, location})\n            } else {\n                ret.push({type: 'identifier', value: tok, location})\n            }\n            i--\n        } else if (c == ':') {\n            ret.push({type: 'colon', location})\n        }\n    }\n    ret.push({type: '<end-of-program>', location: i})\n    return {tokens: ret, i}\n}\n\nfunction describeLocation(token) {\n    if (token) {\n        return token.location\n    }\n    return '<end>'\n}\n\n// Parse a token stream by recursive descent.\n//\n// Returns {node: {*apply(input, conf)}, i}, where i is the position in the\n// token stream and node is one of the filtering nodes defined below.\n// Returns at end of stream or when a token of type until is found.\nfunction parse(tokens, startAt=0, until='none') {\n    let i = startAt\n    let t = tokens[i]\n    let ret = []\n    let commaAccum = []\n    while (t && (until.indexOf(t.type) == -1)) {\n        // Simple cases\n        if (t.type == 'identifier-index') {\n            ret.push(new IdentifierIndex(t.value))\n        } else if (t.type == 'number') {\n            ret.push(new NumberNode(t.value))\n        } else if (t.type == 'quote') {\n            ret.push(new StringNode(t.value))\n        } else if (t.type == 'dot') {\n            ret.push(new IdentityNode())\n        } else if (t.type == 'dot-dot') {\n            ret.push(new RecursiveDescent())\n        } else if (t.type == 'identifier') {\n            if (t.value == 'true' || t.value == 'false')\n                ret.push(new BooleanNode(t.value == 'true'))\n            else if (t.value == 'null')\n                ret.push(new BooleanNode(null))\n            else {\n                // Named function\n                let fname = t.value\n                let args = []\n                if (tokens[i+1] && tokens[i+1].type == 'left-paren') {\n                    i++\n                    while (tokens[i].type != 'right-paren') {\n                        let arg = parse(tokens, i + 1,\n                            ['semicolon', 'right-paren'])\n                        args.push(arg.node)\n                        i = arg.i\n                    }\n                }\n                ret.push(new FunctionCall(fname + '/' + args.length, args))\n            }\n        // Recursive square bracket cases\n        } else if (t.type == 'dot-square') {\n            let r = parseDotSquare(tokens, i)\n            ret.push(r.node)\n            i = r.i\n        } else if (t.type == 'left-square') {\n            // Find the body of the brackets first\n            let r = parse(tokens, i + 1, ['right-square', 'colon'])\n            if (ret.length) {\n                let lhs = makeFilterNode(ret)\n                ret = []\n                if (tokens[r.i].type == 'colon') {\n                    // Slice\n                    if (r.node.length === 0)\n                        r.node = new NumberNode(0)\n                    let e = parse(tokens, r.i + 1, ['right-square'])\n                    if (e.node.length === 0)\n                        e.node = new NumberNode(-1)\n                    ret.push(new SliceNode(lhs, r.node, e.node))\n                    r = e\n                } else if (r.node.length === 0)\n                    ret.push(new SpecificValueIterator(lhs))\n                else\n                    ret.push(new IndexNode(lhs, r.node))\n            } else {\n                ret.push(new ArrayNode(r.node))\n            }\n            i = r.i\n        // Recursive parenthesis case\n        } else if (t.type == 'left-paren') {\n            // Find the body of the brackets first\n            let r = parse(tokens, i + 1, 'right-paren')\n            ret.push(r.node)\n            i = r.i\n        // Object literal\n        } else if (t.type == 'left-brace') {\n            let r = parseObject(tokens, i + 1)\n            ret.push(r.node)\n            i = r.i\n        // Format @x\n        } else if (t.type == 'at') {\n            let n = tokens[++i]\n            if (!n || n.type != 'identifier')\n                throw 'expected identifier after @ at ' +\n                    describeLocation(n)\n            let fmt = n.value\n            if (!formats[fmt])\n                throw 'not a valid format: ' + fmt\n            let q\n            if (tokens[i+1] && tokens[i+1].type == 'quote-interp') {\n                ({q, i} = parseStringInterpolation(tokens, i + 1))\n                i = i\n            }\n            ret.push(new FormatNode(fmt, q))\n        // Comma consumes everything previous and splits in-place\n        // (parsing carries on in this method)\n        } else if (t.type == 'comma') {\n            commaAccum.push(makeFilterNode(ret))\n            ret = []\n        // Pipe consumes everything previous *including* commas\n        // and splits by recursing for the right-hand side.\n        // \"as\" indicates a variable binding.\n        } else if (t.type == 'pipe' || t.type == 'as') {\n            if (commaAccum.length) {\n                // .x,.y | .[1] is the same as (.x,.y) | .[1]\n                commaAccum.push(makeFilterNode(ret))\n                ret = [new CommaNode(commaAccum)]\n                commaAccum = []\n            }\n            let lhs = makeFilterNode(ret)\n            if (t.type == 'as') {\n                let nameTok = tokens[i+1]\n                lhs = new VariableBinding(lhs, nameTok.name)\n                i += 2\n            }\n            let r = parse(tokens, i + 1, until)\n            let rhs = r.node\n            i = r.i\n            if (tokens[i] && until.indexOf(tokens[i].type) != -1)\n                i--\n            ret = [new PipeNode(lhs, rhs)]\n        // Question mark suppresses errors on the preceding filter\n        } else if (t.type == 'question') {\n            let p = ret.pop()\n            if (!p)\n                throw 'unexpected ? without preceding filter at ' +\n                    describeLocation(t)\n            ret.push(new ErrorSuppression(p))\n        // Infix operators\n        } else if (t.type == 'op') {\n            if (ret.length == 0 && t.op == '-' && tokens[i+1].type == 'number') {\n                tokens[i+1].value = -tokens[i+1].value\n                t = tokens[++i]\n                continue\n            }\n            let lhs = makeFilterNode(ret)\n            let op = t.op\n            let stream = [lhs, t]\n            let r = parse(tokens, i + 1, ['op', 'comma', 'pipe', 'right-paren',\n                'right-brace', 'right-square', '<end-of-program>'].concat(until))\n            i = r.i\n            stream.push(r.node)\n            while (i < tokens.length && tokens[i].type == 'op') {\n                stream.push(tokens[i])\n                let r = parse(tokens, i + 1, ['op', 'comma', 'pipe',\n                    'right-paren', 'right-brace', 'right-square', '<end-of-program>'].concat(until))\n                i = r.i\n                stream.push(r.node)\n            }\n            ret = [shuntingYard(stream)]\n            if (tokens[i]) i--\n        // Update-assignment\n        } else if (t.type == 'pipe-equals') {\n            let lhs = makeFilterNode(ret)\n            let r = parse(tokens, i + 1, ['comma', 'pipe', 'right-paren',\n                'right-brace', 'right-square', '<end-of-program>'].concat(until))\n            i = r.i\n            let rhs = r.node\n            ret = [new UpdateAssignment(lhs, rhs)]\n        // Arithmetic update-assignment\n        } else if (t.type == 'op-equals') {\n            let lhs = makeFilterNode(ret)\n            let r = parse(tokens, i + 1, ['comma', 'pipe', 'right-paren',\n                'right-brace', 'right-square', '<end-of-program>'].concat(until))\n            i = r.i\n            let rhs = r.node\n            rhs = shuntingYard([new IdentityNode(), {type: 'op', op: t.op},\n                rhs])\n            ret = [new UpdateAssignment(lhs, rhs)]\n        // reduce .[] as $item (0, . + $item)\n        } else if (t.type == 'reduce') {\n            let r = parse(tokens, i + 1, ['as'])\n            i = r.i\n            let generator = r.node\n            i++ // 'as'\n            let name = tokens[i].name\n            i++\n            if (tokens[i].type != 'left-paren')\n                throw 'expected left-paren in reduce at ' +\n                    describeLocation(tokens[i])\n            r = parse(tokens, i + 1, ['semicolon'])\n            i = r.i\n            let init = r.node\n            r = parse(tokens, i + 1, ['right-paren'])\n            i = r.i\n            let expr = r.node\n            ret.push(new ReduceNode(generator, name, init, expr))\n        // Interpolated string literal\n        } else if (t.type == 'quote-interp') {\n            let q\n            ({q, i} = parseStringInterpolation(tokens, i))\n            ret.push(q)\n        // Variable reference\n        } else if (t.type == 'variable') {\n            ret.push(new VariableReference(t.name))\n        // Conditional if-then-(elif-then)*-else?-end\n        } else if (t.type == 'if') {\n            let conds = []\n            let trueExprs = []\n            let falseExpr = null\n            while (tokens[i] && (tokens[i].type == 'if' || tokens[i].type == 'elif')) {\n                let cond = parse(tokens, i + 1, ['then'])\n                if (!tokens[cond.i] || tokens[cond.i].type != 'then')\n                    throw 'expected then at ' +\n                        describeLocation(tokens[cond.i]) +\n                        ', from ' + tokens[i].type + ' at ' + tokens[i].location\n                let trueExpr = parse(tokens, cond.i + 1, ['else', 'elif', 'end'])\n                if (trueExpr.i == cond.i + 1)\n                    throw 'expected expression after then at ' +\n                        describeLocation(tokens[cond.i + 1]) + ', not ' +\n                        tokens[cond.i + 1].type\n                i = trueExpr.i\n                conds.push(cond.node)\n                trueExprs.push(trueExpr.node)\n            }\n            if (tokens[i] && tokens[i].type == 'else') {\n                let elseCase = parse(tokens, i + 1, ['end'])\n                i = elseCase.i\n                falseExpr = elseCase.node\n            }\n            if (!tokens[i] || tokens[i].type != 'end')\n                throw 'expected end at ' + describeLocation(tokens[i]) + ' from if at ' + t.location\n            ret.push(new IfNode(conds, trueExprs, falseExpr))\n        } else if (t.type == '<end-of-program>' && until == 'none') {\n            break\n        } else {\n            throw 'could not handle token ' + t.type + ' at ' + describeLocation(t) + (until != 'none' ? ', expected ' + until.join('/') : '')\n        }\n        t = tokens[++i]\n    }\n    // If a comma appeared this array is non-empty and contains all\n    // previous branches.\n    if (commaAccum.length) {\n        commaAccum.push(makeFilterNode(ret))\n        return {node: new CommaNode(commaAccum), i}\n    }\n    return {node: makeFilterNode(ret), i}\n}\n\nfunction makeFilterNode(ret) {\n    if (ret.length == 1)\n        return ret[0]\n    return new FilterNode(ret)\n}\n\n// Consumes pairs (quote-interp, expression up to rparen)* followed by\n// a bare string and returns a StringLiteral node with the interleaving\n// lists.\nfunction parseStringInterpolation(tokens, i) {\n    let t = tokens[i]\n    let strings = []\n    let interps = []\n    strings.push(t.value)\n    // Always followed by a paren expression afterwards\n    let inner = parse(tokens, i + 1, ['right-paren'])\n    i = inner.i + 1\n    interps.push(inner.node)\n    while (tokens[i].type == 'quote-interp') {\n        strings.push(tokens[i].value)\n        inner = parse(tokens, i + 1, ['right-paren'])\n        i = inner.i + 1\n        interps.push(inner.node)\n    }\n    // Must be the ending quote now\n    strings.push(tokens[i].value)\n    return {q:new StringLiteral(strings, interps), i}\n}\n\nfunction parseDotSquare(tokens, startAt=0) {\n    let i = startAt\n    let ds = tokens[i]\n    i++\n    if (tokens[i].type == 'right-square')\n        return {node: new GenericValueIterator(), i}\n    let r = parse(tokens, i, ['right-square', 'colon'])\n    if (tokens[r.i].type == 'colon') {\n        // Slice\n        let fr = r\n        if (fr.length === 0)\n            fr.node = new NumberNode(0)\n        r = parse(tokens, r.i + 1, ['right-square'])\n        if (r.length === 0)\n            r.node = new NumberNode(-1)\n        return {node: new GenericSlice(fr.node, r.node), i: r.i}\n    }\n    return {node: new GenericIndex(r.node), i: r.i}\n}\n\n// Parse an object literal, expecting to start immediately inside the\n// left brace and to consume up to and including the right brace.\nfunction parseObject(tokens, startAt=0) {\n    let i = startAt\n    let fields = []\n    while (tokens[i].type != 'right-brace') {\n        if (tokens[i].type == 'identifier') {\n            // bare name x\n            let ident = tokens[i++]\n            if (tokens[i].type == 'colon') {\n                // with value x: val\n                let r = parse(tokens, i + 1, ['comma', 'right-brace'])\n                i = r.i\n                fields.push({\n                    key: new StringNode(ident.value),\n                    value: r.node,\n                })\n                i--\n            } else if (tokens[i].type == 'comma') {\n                // no value: equivalent to x : .x\n                fields.push({\n                    key: new StringNode(ident.value),\n                    value: new IdentifierIndex(ident.value),\n                })\n            } else if (tokens[i].type == 'right-brace') {\n                // ditto, last field: equivalent to x : .x\n                fields.push({\n                    key: new StringNode(ident.value),\n                    value: new IdentifierIndex(ident.value),\n                })\n                i--\n            }\n        } else if (tokens[i].type == 'quote') {\n            // quoted-string key: \"x\" : val\n            let ident = tokens[i++]\n            if (tokens[i].type == 'colon') {\n                let r = parse(tokens, i + 1, ['comma', 'right-brace'])\n                i = r.i\n                fields.push({\n                    key: new StringNode(ident.value),\n                    value: r.node,\n                })\n                i--\n            } else {\n                throw 'unexpected ' + tokens[i].type + ', expected colon at ' +\n                    describeLocation(tokens[i])\n            }\n        } else if (tokens[i].type == 'left-paren') {\n            // computed key: (.x | .y) : val\n            let kr = parse(tokens, i + 1, 'right-paren')\n            i = kr.i + 1\n            if (tokens[i].type == 'colon') {\n                let r = parse(tokens, i + 1, ['comma', 'right-brace'])\n                i = r.i\n                fields.push({\n                    key: kr.node,\n                    value: r.node,\n                })\n                i--\n            } else {\n                throw 'unexpected ' + tokens[i].type + ', expected colon at ' +\n                    describeLocation(tokens[i])\n            }\n        } else {\n            throw 'unexpected ' + tokens[i].type + ' at ' +\n                describeLocation(tokens[i]) + ' in object at ' +\n                describeLocation(tokens[startAt - 1])\n        }\n        i++\n        // Consume a comma after a field\n        if (tokens[i].type == 'comma')\n            i++\n    }\n    return {\n        node: new ObjectNode(fields),\n        i\n    }\n}\n\nfunction shuntingYard(stream) {\n    const prec = { '+' : 5, '-' : 5, '*' : 10, '/' : 10, '%' : 10,\n        '//' : 2, '==': 3, '!=': 3, '>': 3, '<': 3, '>=': 3, '<=': 3 }\n    let output = []\n    let operators = []\n    for (let x of stream) {\n        if (x.type == 'op') {\n            while (operators.length && prec[operators[0].op] >= prec[x.op])\n                output.push(operators.shift())\n            operators.unshift(x)\n        } else {\n            output.push(x)\n        }\n    }\n    for (let o of operators)\n        output.push(o)\n    let constructors = {\n        '+': AdditionOperator,\n        '*': MultiplicationOperator,\n        '-': SubtractionOperator,\n        '/': DivisionOperator,\n        '%': ModuloOperator,\n        '//': AlternativeOperator,\n        '==': EqualsOperator,\n        '!=': NotEqualsOperator,\n        '<': LessThanOperator,\n        '>': GreaterThanOperator,\n        '<=': LessEqualsOperator,\n        '>=': GreaterEqualsOperator,\n    }\n    let stack = []\n    for (let o of output) {\n        if (o.type == 'op') {\n            let r = stack.pop()\n            let l = stack.pop()\n            stack.push(new constructors[o.op](l, r))\n        } else {\n            stack.push(o)\n        }\n    }\n    return stack[0]\n}\n\nfunction trace_helper(input, conf, dest, rest) {\n    let filter = rest[0]\n    for (let v of filter.apply(input, conf)) {\n        let next = []\n        dest.push({\n            node: filter,\n            output: v,\n            next,\n            variables: JSON.parse(JSON.stringify(conf.variables)),\n        })\n        if (rest.length > 1) {\n            trace_helper(v, conf, next, rest.slice(1))\n        }\n    }\n}\n\nfunction sourced_trace_helper(input, conf, dest, rest) {\n    let forward = []\n    let src = this\n    while (src.source) {\n        if (src.filter) {\n            forward.unshift(src.filter)\n            src = src.source\n        } else {\n            src = src.source\n        }\n    }\n    forward.unshift(src)\n    trace_helper(input, conf, dest, forward)\n}\n\n// Convert a value to a consistent type name, addressing the issue\n// that arrays are objects.\nfunction nameType(o) {\n    if (o === null) return 'null'\n    if (typeof o == 'number') return 'number'\n    if (typeof o == 'string') return 'string'\n    if (typeof o == 'boolean') return 'boolean'\n    if (o instanceof Array) return 'array'\n    if (typeof o == 'object') return 'object'\n}\n\n// Parse node classes follow. Parse nodes are:\n//   FilterNode, generic juxtaposition combination\n//   IndexNode, lhs[rhs]\n//   SliceNode, lhs[from:to]\n//   GenericIndex, .[index]\n//   IdentifierIndex .index (delegates to GenericIndex(\"index\"))\n//   GenericSlice, .[from:to]\n//   IdentityNode, .\n//   ValueNode, parent of string/number/boolean\n//   StringNode, \"abc\"\n//   NumberNode, 123.45\n//   BooleanNode, true/false\n//   SpecificValueIterator, lhs[] (yields values from lhs)\n//   GenericValueIterator, .[] (yields values from input)\n//   CommaNode, .x, .y, .z\n//   ArrayNode, [...]\n//   PipeNode, a | b | c\n//   ObjectNode { x : y, z, \"a b\" : 12, (.x.y) : .z }\n//   RecursiveDescent, ..\n//   OperatorNode, a binary infix operator\n//   AdditionOperator, a + b\n//   MultiplicationOperator, a * b\n//   SubtractionOperator, a - b\n//   DivisionOperator, a / b\n//   ModuloOperator, a % b\n//   EqualsOperator, a == b\n//   NotEqualsOperator, a != b\n//   AlternativeOperator, a // b\n//   UpdateAssignment, .x.y |= .z\n//   FunctionCall, fname(arg1; arg2)\n//   FormatNode, @format, @format \"a\\(...)\"\n//   ErrorSuppression, foo?\n//   VariableBinding, ... as $x (not the pipe)\n//   VariableReference, $x\n//   ReduceNode, reduce .[] as $x (0; . + $x)\n//   IfNode, if a then b elif c then d else e end\nclass ParseNode {\n    trace(input, conf, dest) {\n        for (let v of this.apply(input, conf)) {\n            dest.push({\n                node: this,\n                output: v,\n                next: [],\n            })\n        }\n    }\n    toString() {\n        return '<' + this.constructor.name + '>'\n    }\n}\nclass FilterNode extends ParseNode {\n    constructor(nodes) {\n        super()\n        this.length = nodes.length\n        let p = nodes.pop()\n        if (p) {\n            this.filter = p\n            this.source = nodes.length == 1 ? nodes[0] : new FilterNode(nodes)\n        }\n    }\n    * apply(input, conf) {\n        if (!this.filter)\n            return\n        for (let v of this.source.apply(input, conf)) {\n            yield* this.filter.apply(v, conf)\n        }\n    }\n    * paths(input, conf) {\n        if (!this.filter) {\n            return []\n        }\n        for (let v of this.source.paths(input, conf)) {\n            for (let w of this.filter.paths(input, conf)) {\n                yield v.concat(w)\n            }\n        }\n    }\n    trace = sourced_trace_helper\n    toString() {\n        return (this.source ? this.source.toString() : '') + (this.filter ? this.filter.toString() : '')\n    }\n}\nclass IndexNode extends ParseNode {\n    constructor(lhs, index) {\n        super()\n        this.lhs = lhs\n        this.index = index\n    }\n    * apply(input, conf) {\n        for (let l of this.lhs.apply(input, conf)) {\n            let t = nameType(l)\n            for (let i of this.index.apply(input, conf)) {\n                if (t == 'array' && nameType(i) != 'number')\n                    throw 'Cannot index array with ' + nameType(i) + ' ' +\n                        JSON.stringify(i)\n                else if (t == 'object' && nameType(i) != 'string')\n                    throw 'Cannot index object with ' + nameType(i) + ' ' +\n                        JSON.stringify(i)\n                if (typeof i == 'number' && i < 0 && nameType(l) == 'array')\n                    yield l[l.length + i]\n                else\n                    yield typeof l[i] == 'undefined' ? null : l[i]\n            }\n        }\n    }\n    * paths(input, conf) {\n        for (let l of this.lhs.paths(input, conf))\n            for (let a of this.index.apply(input, conf))\n                yield l.concat([a])\n    }\n    toString() {\n        return this.lhs.toString() + '[' + this.index.toString() + ']'\n    }\n}\nclass SliceNode extends ParseNode {\n    constructor(lhs, from, to) {\n        super()\n        this.lhs = lhs\n        this.from = from\n        this.to = to\n    }\n    * apply(input, conf) {\n        for (let l of this.lhs.apply(input, conf))\n            for (let s of this.from.apply(input, conf)) {\n                if (s < 0) s += l.length\n                for (let e of this.to.apply(input, conf)) {\n                    if (e < 0) e += l.length\n                    yield l.slice(s, e)\n                }\n            }\n    }\n    * paths(input, conf) {\n        for (let l of this.lhs.paths(input, conf))\n            for (let a of this.from.apply(input, conf))\n                for (let b of this.to.apply(input, conf))\n                    yield l.concat([{start:a, end:b}])\n    }\n    toString() {\n        return this.lhs.toString() + '[' + this.from.toString() + ':' + this.to.toString() + ']'\n    }\n}\nclass GenericIndex extends ParseNode {\n    constructor(innerNode) {\n        super()\n        this.index = innerNode\n    }\n    * apply(input, conf) {\n        let t = nameType(input)\n        for (let i of this.index.apply(input, conf)) {\n            if (t == 'array' && nameType(i) != 'number')\n                throw 'Cannot index array with ' + nameType(i) + ' ' +\n                    JSON.stringify(i)\n            else if (t == 'object' && nameType(i) != 'string')\n                throw 'Cannot index object with ' + nameType(i) + ' ' +\n                    JSON.stringify(i)\n            if (typeof i == 'number' && i < 0 && nameType(input) == 'array')\n                yield input[input.length + i]\n            else\n                yield typeof input[i] == 'undefined' ? null : input[i]\n        }\n    }\n    * paths(input, conf) {\n        for (let a of this.index.apply(input, conf))\n            yield [a]\n    }\n}\nclass IdentifierIndex extends GenericIndex {\n    constructor(v) {\n        super(new StringNode(v))\n    }\n    toString() {\n        return '.' + this.index.value\n    }\n}\nclass GenericSlice extends ParseNode {\n    constructor(fr, to) {\n        super()\n        this.from = fr\n        this.to = to\n    }\n    * apply(input, conf) {\n        for (let l of this.from.apply(input, conf)) {\n            if (l < 0) l += input.length\n            for (let r of this.to.apply(input, conf)) {\n                if (r < 0)\n                    r += input.length\n                yield input.slice(l, r)\n            }\n        }\n    }\n    * paths(input, conf) {\n        for (let l of this.from.apply(input, conf))\n            for (let r of this.to.apply(input, conf))\n                yield [{start: l, end: r}]\n    }\n    toString() {\n        return '.[' + this.from.toString() + ':' + this.to.toString() + ']'\n    }\n}\nclass IdentityNode extends ParseNode {\n    constructor() {\n        super()\n    }\n    * apply(input, conf) {\n        yield input\n    }\n    * paths(input, conf) {\n        yield []\n    }\n    toString() {\n        return '.'\n    }\n}\nclass ValueNode extends ParseNode {\n    constructor(v) {\n        super()\n        this.value = v\n    }\n    * apply() {\n        yield this.value\n    }\n    * paths(input, conf) {\n        yield this.value\n    }\n    toString() {\n        return JSON.stringify(this.value)\n    }\n}\nclass StringNode extends ValueNode {\n    constructor(v) {\n        super(v)\n    }\n}\nclass StringLiteral extends ParseNode {\n    constructor(strings, interpolations) {\n        super()\n        this.strings = strings\n        this.interpolations = interpolations\n    }\n    * apply(input, conf) {\n        yield* this.applyEscape(input, formats.text, conf)\n    }\n    * applyEscape(input, esc, conf, startAt=0) {\n        let s = this.strings[startAt]\n        let i = this.interpolations[startAt]\n        if (!i) return yield s\n        for (let v of this.interpolations[startAt].apply(input, conf)) {\n            for (let r of this.applyEscape(input, esc, conf, startAt + 1)) {\n                yield s + esc(v) + r\n            }\n        }\n    }\n    toString() {\n        let s = ''\n        for (let i = 0; i < this.strings.length; i++) {\n            s += this.strings[i].replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n            if (this.interpolations[i])\n                s += '\\\\(' + this.interpolations[i].toString() + ')'\n        }\n        return '\"' + s + '\"'\n    }\n}\nclass NumberNode extends ValueNode {\n    constructor(v) {\n        super(v)\n    }\n    toString() {\n        return this.value.toString()\n    }\n}\nclass BooleanNode extends ValueNode {\n    constructor(v) {\n        super(v)\n    }\n    toString() {\n        return this.value ? 'true' : 'false'\n    }\n}\nclass SpecificValueIterator extends ParseNode {\n    constructor(source) {\n        super()\n        this.source = source\n        this.filter = new GenericValueIterator()\n    }\n    * apply(input, conf) {\n        for (let o of this.source.apply(input, conf))\n            yield* Object.values(o)\n    }\n    * paths(input, conf) {\n        for (let [p, v] of this.zip(this.source.paths(input, conf),\n                this.source.apply(input, conf))) {\n                if (nameType(v) == 'array')\n                    for (let i = 0; i < v.length; i++)\n                        yield p.concat([i])\n                else\n                    for (let i of Object.keys(v)) {\n                        yield p.concat([i])\n                    }\n        }\n    }\n    * zip(a, b) {\n        let aa = a[Symbol.iterator]()\n        let bb = b[Symbol.iterator]()\n        let v1 = aa.next()\n        let v2 = bb.next()\n        while (!v1.done && !v2.done) {\n            yield [v1.value, v2.value]\n            v1 = aa.next()\n            v2 = bb.next()\n        }\n    }\n    toString() {\n        return this.source.toString() + '[]'\n    }\n    trace = sourced_trace_helper\n}\nclass GenericValueIterator extends ParseNode {\n    constructor() {\n        super()\n    }\n    * apply(input, conf) {\n        if (nameType(input) == 'array')\n            yield* input\n        else\n            yield* Object.values(input)\n    }\n    * paths(input, conf) {\n        if (nameType(input) == 'array')\n            for (let i = 0; i < input.length; i++)\n                yield [i]\n        else\n            for (let o of Object.keys(input))\n                yield [o]\n    }\n    toString() {\n        return '.[]'\n    }\n}\nclass CommaNode extends ParseNode {\n    constructor(branches) {\n        super()\n        this.branches = branches\n    }\n    * apply(input, conf) {\n        for (let b of this.branches)\n            yield* b.apply(input, conf)\n    }\n    * paths(input, conf) {\n        for (let b of this.branches)\n            yield* b.paths(input, conf)\n    }\n    toString() {\n        return this.branches.join(', ')\n    }\n}\nclass ArrayNode extends ParseNode {\n    constructor(body) {\n        super()\n        this.body = body\n    }\n    * apply(input, conf) {\n        yield Array.from(this.body.apply(input, conf))\n    }\n    toString() {\n        return '[' + this.body + ']'\n    }\n}\nclass PipeNode extends ParseNode {\n    constructor(lhs, rhs) {\n        super()\n        this.lhs = lhs\n        this.rhs = rhs\n        this.isPipe = true\n    }\n    toString() {\n        return `${this.lhs} | ${this.rhs}`\n    }\n    * apply(input, conf) {\n        for (let v of this.lhs.apply(input, conf))\n            for (let q of this.rhs.apply(v, conf))\n                yield q\n    }\n    * paths(input, conf) {\n        for (let [p, v] of this.zip(this.lhs.paths(input, conf),\n                this.lhs.apply(input, conf))) {\n            for (let p2 of this.rhs.paths(v, conf)) {\n                yield p.concat(p2)\n            }\n        }\n    }\n    * zip(a, b) {\n        let aa = a[Symbol.iterator]()\n        let bb = b[Symbol.iterator]()\n        let v1 = aa.next()\n        let v2 = bb.next()\n        while (!v1.done && !v2.done) {\n            yield [v1.value, v2.value]\n            v1 = aa.next()\n            v2 = bb.next()\n        }\n    }\n    trace(input, conf, dest) {\n        for (let v of this.lhs.apply(input, conf)) {\n            let next = []\n            let more = {}\n            if (this.lhs instanceof VariableBinding)\n                more.variableValue = conf.variables[this.lhs.name]\n            dest.push({\n                node: this.lhs,\n                output: v,\n                next,\n                variables: JSON.parse(JSON.stringify(conf.variables)),\n                ...more\n            })\n            this.rhs.trace(v, conf, next)\n        }\n    }\n}\nclass ObjectNode extends ParseNode {\n    constructor(fields) {\n        super()\n        this.fields = fields\n    }\n    * apply(input, conf) {\n        let obj = {}\n        let values = {}\n        let keys = []\n        for (let {key, value} of this.fields) {\n            for (let k of key.apply(input, conf)) {\n                keys.push(k)\n                values[k] = []\n                for (let v of value.apply(input, conf))\n                    values[k].push(v)\n            }\n        }\n        yield* this.helper(keys, values, 0, {})\n    }\n    * helper(keys, values, startAt, obj) {\n        if (startAt >= keys.length) {\n            yield Object.assign({}, obj)\n            return\n        }\n        let k = keys[startAt]\n        for (let v of values[k]) {\n            obj[k] = v\n            yield* this.helper(keys, values, startAt + 1, obj)\n        }\n    }\n    toString() {\n        return '{' + this.fields.map(({key, value}) => key.toString() + ': ' + value.toString()).join(', ') + '}'\n    }\n}\nclass RecursiveDescent extends ParseNode {\n    constructor() {\n        super()\n    }\n    * apply(input, conf) {\n        yield* this.recurse(input)\n    }\n    * recurse(s) {\n        yield s\n        let t = nameType(s)\n        if (t == 'array' || t == 'object')\n            for (let v of Object.values(s))\n                yield* this.recurse(v)\n    }\n    * paths(input, conf) {\n        yield* this.recursePaths(input, [])\n    }\n    * recursePaths(s, prefix) {\n        yield prefix\n        let t = nameType(s)\n        if (t == 'array')\n            for (let i = 0; i < s.length; i++)\n                yield* this.recursePaths(s[i], prefix.concat([i]))\n        else if (t == 'object')\n            for (let [k,v] of Object.entries(s))\n                yield* this.recursePaths(v, prefix.concat([k]))\n    }\n    toString() {\n        return '..'\n    }\n}\nclass OperatorNode extends ParseNode {\n    constructor(l, r) {\n        super()\n        this.l = l\n        this.r = r\n    }\n    * apply(input, conf) {\n        for (let rr of this.r.apply(input, conf))\n            for (let ll of this.l.apply(input, conf))\n                yield this.combine(ll, rr, nameType(ll), nameType(rr))\n    }\n    trace(input, conf, dest) {\n        for (let v of this.l.apply(input, conf)) {\n            let next = []\n            dest.push({\n                node: this.l,\n                output: v,\n                next,\n                subsidiary: 'left'\n            })\n            for (let v2 of this.r.apply(input, conf)) {\n                let next2 = []\n                next.push({\n                    node: this.r,\n                    output: v2,\n                    next: next2,\n                    subsidiary: 'right',\n                })\n                let result = this.combine(v, v2, nameType(v), nameType(v2))\n                let next3 = []\n                next2.push({\n                    node: this,\n                    output: result,\n                    next: next3,\n                })\n            }\n        }\n    }\n}\nclass AdditionOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt == 'number' && rt == 'number')\n            return l + r\n        if (l === null)\n            return r\n        if (r === null)\n            return l\n        if (lt == 'string' && rt == 'string')\n            return l + r\n        if (lt == 'array' && rt == 'array')\n            return l.concat(r)\n        if (lt == 'object' && rt == 'object')\n            return Object.assign(Object.assign({}, l), r)\n        throw 'type mismatch in +:' + lt + ' and ' + rt + ' cannot be added'\n    }\n    toString() {\n        return this.l + ' + ' + this.r\n    }\n}\nclass MultiplicationOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt == 'number' && rt == 'number')\n            return l * r\n        if (lt == 'number' && rt == 'string')\n            return this.repeat(r, l)\n        if (lt == 'string' && rt == 'number')\n            return this.repeat(l, r)\n        if (lt == 'object' && rt == 'object')\n            return this.merge(Object.assign({}, l), r)\n        throw 'type mismatch in *:' + lt + ' and ' + rt + ' cannot be multiplied'\n    }\n    repeat(s, n) {\n        if (n == 0)\n            return null;\n        let r = []\n        for (let i = 0; i < n; i++)\n            r.push(s)\n        return r.join('')\n    }\n    merge(l, r) {\n        for (let k of Object.keys(r)) {\n            if (!l.hasOwnProperty(k))\n                l[k] = r[k]\n            else if (nameType(l[k]) != 'object' || nameType(r[k]) != 'object')\n                l[k] = r[k]\n            else\n                this.merge(l[k], r[k])\n        }\n        return l\n    }\n    toString() {\n        return this.l + ' * ' + this.r\n    }\n}\nclass SubtractionOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt == 'number' && rt == 'number')\n            return l - r\n        if (l == null || r == null)\n            throw 'type mismatch in -'\n        if (lt == 'array' && rt == 'array')\n            return l.filter(x => r.indexOf(x) == -1)\n        throw 'type mismatch in -:' + lt + ' and ' + rt + ' cannot be subtracted'\n    }\n    toString() {\n        return this.l + ' - ' + this.r\n    }\n}\nclass DivisionOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt == 'number' && rt == 'number')\n            return l / r\n        if (lt == 'string' && rt == 'string')\n            return l.split(r)\n        throw 'type mismatch in -:' + lt + ' and ' + rt + ' cannot be divided'\n    }\n    toString() {\n        return this.l + ' / ' + this.r\n    }\n}\nclass ModuloOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt == 'number' && rt == 'number')\n            return l % r\n        throw 'type mismatch in -:' + lt + ' and ' + rt + ' cannot be divided (remainder)'\n    }\n    toString() {\n        return this.l + ' % ' + this.r\n    }\n}\nclass LessThanOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        return compareValues(l, r) < 0\n    }\n    toString() {\n        return this.l + ' < ' + this.r\n    }\n}\nclass GreaterThanOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        return compareValues(l, r) > 0\n    }\n    toString() {\n        return this.l + ' > ' + this.r\n    }\n}\nclass LessEqualsOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        return compareValues(l, r) <= 0\n    }\n    toString() {\n        return this.l + ' <= ' + this.r\n    }\n}\nclass GreaterEqualsOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        return compareValues(l, r) >= 0\n    }\n    toString() {\n        return this.l + ' >= ' + this.r\n    }\n}\nclass EqualsOperator extends OperatorNode {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        if (lt != rt)\n            return false\n        if (lt == 'number' || lt == 'string' || lt == 'boolean' || lt == 'null')\n            return l == r\n        if (lt == 'array') {\n            if (l.length != r.length)\n                return false\n            for (let i = 0; i < l.length; i++)\n                if (!this.combine(l[i], r[i], nameType(l[i]), nameType(r[i])))\n                    return false\n            return true\n        }\n        let lk = Object.keys(l)\n        let rk = Object.keys(r)\n        if (lk.length != rk.length)\n            return false\n        for (let k of lk) {\n            if (!r.hasOwnProperty(k))\n                return false\n            if (!this.combine(l[k], r[k], nameType(l[k]), nameType(r[k])))\n                return false\n        }\n        return true\n    }\n    toString() {\n        return this.l + ' == ' + this.r\n    }\n}\nclass NotEqualsOperator extends EqualsOperator {\n    constructor(l, r) {\n        super(l, r)\n    }\n    combine(l, r, lt, rt) {\n        return !super.combine(l, r, lt, rt)\n    }\n    toString() {\n        return this.l + ' != ' + this.r\n    }\n}\nclass AlternativeOperator extends ParseNode {\n    constructor(l, r) {\n        super()\n        this.lhs = l\n        this.rhs = r\n    }\n    * apply(input, conf) {\n        let found = false\n        for (let v of this.lhs.apply(input, conf)) {\n            if (v !== null) found = true\n            yield v\n        }\n        if (!found)\n            yield* this.rhs.apply(input, conf)\n    }\n    toString() {\n        return this.l + ' // ' + this.r\n    }\n}\nclass UpdateAssignment extends ParseNode {\n    constructor(l, r) {\n        super()\n        this.l = l\n        this.r = r\n    }\n    * apply(input, conf) {\n        input = JSON.parse(JSON.stringify(input))\n        for (let p of this.l.paths(input, conf)) {\n            let it = this.r.apply(this.get(input, p), conf).next()\n            if (it.done)\n                input = this.update(input, p, null, true)\n            else\n                input = this.update(input, p, it.value)\n        }\n        yield input\n    }\n    // Pluck the value at a path out of an object\n    get(obj, p) {\n        let o = obj\n        for (let i of p)\n            o = o[i]\n        return o\n    }\n    // Set the value at path p to v in obj,\n    // or delete the key if del is true.\n    update(obj, p, v, del=false) {\n        let o = obj\n        let last = p.pop()\n        for (let i of p)\n            o = o[i]\n        if (typeof last == 'undefined')\n            return v\n        o[last] = v\n        if (del)\n            delete o[last]\n        return obj\n    }\n    toString() {\n        return this.l + ' |= ' + this.r\n    }\n}\nclass FunctionCall extends ParseNode {\n    constructor(fname, args) {\n        super()\n        this.name = fname\n        this.args = args\n    }\n    apply(input, conf) {\n        let func\n        let ufa = conf.userFuncArgs[this.name]\n        if (ufa)\n            func = function(input, conf, args) {\n                return ufa.apply(input, conf)\n            }\n        else if (!func)\n            func = functions[this.name]\n        if (!func)\n            throw 'no such function ' + this.name\n        let argStack = []\n        return func(input, conf, this.args)\n    }\n    paths(input, conf) {\n        let ufa = conf.userFuncArgs[this.name]\n        if (ufa)\n            return ufa.paths(input, conf)\n        let func = functions[this.name + '-paths']\n        if (!func)\n            throw 'no paths for ' + this.name\n        return func(input, conf, this.args)\n    }\n    trace(input, conf, dest) {\n        if (this.args.length == 1 && !conf.userFuncArgs[this.name] && this.ordinary) {\n            let func = functions[this.name];\n            if (func.params && func.params.length > 0) {\n                if (func.params[0].mode == 'defer') {\n                    return super.trace(input, conf, dest)\n                }\n            }\n            for (let a1 of this.args[0].apply(input, conf)) {\n                let next = []\n                let paramLabel = 'arg1'\n                if (func.params && func.params.length > 0 && func.params[0].label)\n                    paramLabel = func.params[0].label;\n                dest.push({\n                    node: this.args[0],\n                    output: a1,\n                    next,\n                    subsidiary: paramLabel\n                })\n                for (let result of func(input, conf, [new ValueYielder(a1)])) {\n                    let next2 = []\n                    next.push({\n                        node: this,\n                        output: result,\n                        next: next2,\n                    })\n                }\n            }    \n        } else {\n            return super.trace(input, conf, dest)\n        }\n    }\n    get ordinary() {\n        let func = functions[this.name];\n        if (!func) return true;\n        if (func.params && func.params.length > 0) {\n            if (func.params[0].mode == 'defer') {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        if (this.args.length == 0)\n            return this.name.replace(/\\/.*$/, '')\n        else\n            return this.name.replace(/\\/.*$/, '') + '(' + this.args.join('; ') + ')'\n    }\n}\nclass FormatNode extends ParseNode {\n    constructor(fname, quote) {\n        super()\n        this.name = fname\n        this.string = quote\n    }\n    * apply(input, conf) {\n        if (typeof this.string === 'undefined')\n            return yield formats[this.name](input)\n        yield* this.string.applyEscape(input, formats[this.name], conf)\n    }\n    toString() {\n        if (this.string)\n            return '@' + this.name + ' ' + this.string\n        else\n            return '@' + this.name\n    }\n}\nclass ErrorSuppression extends ParseNode {\n    constructor(inner) {\n        super()\n        this.inner = inner\n    }\n    * apply(input, conf) {\n        try {\n            for (let o of this.inner.apply(input, conf))\n                if (o !== null)\n                    yield o\n        } catch {\n        }\n    }\n    * paths(input, conf) {\n        try {\n            for (let [o,p] of zip(this.inner.apply(input, conf),\n                    this.inner.paths(input, conf)))\n                if (o !== null)\n                    yield p\n        } catch {\n        }\n    }\n    toString() {\n        return this.inner + '?'\n    }\n}\nclass VariableBinding extends ParseNode {\n    constructor(lhs, name) {\n        super()\n        this.value = lhs\n        this.name = name\n    }\n    * apply(input, conf) {\n        for (let v of this.value.apply(input, conf)) {\n            conf.variables[this.name] = v\n            yield input\n        }\n        delete conf.variables[this.name]\n    }\n    toString() {\n        return this.value + ' as $' + this.name\n    }\n}\nclass VariableReference extends ParseNode {\n    constructor(name) {\n        super()\n        this.name = name\n    }\n    * apply(input, conf) {\n        yield conf.variables[this.name]\n    }\n    toString() {\n        return '$' + this.name\n    }\n}\nclass ReduceNode extends ParseNode {\n    constructor(generator, name, init, expr) {\n        super()\n        this.generator = generator\n        this.name = name\n        this.init = init\n        this.expr = expr\n    }\n    * apply(input, conf) {\n        // This uses all values of the initialiser, but only the\n        // last value of the reduction expression is retained. This\n        // seems to match jq proper's behaviour, but jq has odd\n        // errors in mixed cases that seem unnecessary.\n        for (let accum of this.init.apply(input, conf)) {\n            for (let v of this.generator.apply(input, conf)) {\n                conf.variables[this.name] = v\n                for (let a of this.expr.apply(accum, conf))\n                    accum = a\n            }\n            delete conf.variables[this.name]\n            yield accum\n        }\n    }\n    toString() {\n        return 'reduce ' + this.generator + ' as $' + this.name + '(' + this.init + '; ' + this.expr + ')'\n    }\n}\nclass IfNode extends ParseNode {\n    constructor(conditions, thens, elseBranch) {\n        super()\n        this.conditions = conditions\n        this.thens = thens\n        this.elseBranch = elseBranch\n    }\n    * apply(input, conf) {\n        for (let [c,t] of zip(this.conditions, this.thens)) {\n            for (let cond of c.apply(input, conf)) {\n                if (cond) {\n                    for (let o of t.apply(input, conf))\n                        yield o\n                    return\n                }\n            }\n        }\n        if (this.elseBranch) {\n            yield* this.elseBranch.apply(input, conf)\n            return\n        }\n        yield input\n    }\n    toString() {\n        let s = ''\n        for (let [c,t] of zip(this.conditions, this.thens))\n            s += 'if ' + c + ' then ' + t + ' el'\n        if (this.elseBranch) {\n            return s + 'se ' + this.elseBranch + ' end'\n        }\n        return s.slice(0, -2) + 'end'\n    }\n}\n\nclass ValueYielder {\n    /* This is used internally for evaluating functions at specific values. */\n    constructor(v) {\n        this.value = v\n    }\n    * apply(input, conf) {\n        yield this.value\n    }\n    toString() {\n        return this.value.toString()\n    }\n}\n\nconst formats = {\n    text(v) {\n        if (typeof v == 'string')\n            return v\n        return prettyPrint(v, '', '', '')\n    },\n    json(v) {\n        return prettyPrint(v, '', '', '')\n    },\n    html(v) {\n        if (typeof v != 'string')\n            v = prettyPrint(v, '', '', '')\n        return v.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(\n            /&/g, '&amp;').replace(/'/g, '&apos;').replace(/\"/g, '&quot;')\n    },\n    uri(v) {\n        if (typeof v != 'string')\n            v = prettyPrint(v, '', '', '')\n        return escape(v)\n    },\n    csv(v) {\n        if (nameType(v) != 'array')\n            throw 'cannot csv-format ' + nameType(v) + ', only array'\n        return v.map(x => {\n            if (typeof x == 'string')\n                return '\"' + x.replace(/\"/g, '\"\"') + '\"'\n            else if (typeof x == 'number')\n                return '' + x\n            else if (x === null)\n                return ''\n            else\n                throw 'type ' + nameType(x) + ' not valid in a csv row'\n        }).join(',')\n    },\n    tsv(v) {\n        if (nameType(v) != 'array')\n            throw 'cannot tsv-format ' + nameType(v) + ', only array'\n        return v.map(x => {\n            if (typeof x == 'string')\n                return escapeString(x)\n            else if (typeof x == 'number')\n                return '' + x\n            else if (x === null)\n                return ''\n            else\n                throw 'type ' + nameType(x) + ' not valid in a tsv row'\n        }).join('\\t')\n    },\n    base64(v) {\n        if (typeof v != 'string')\n            v = prettyPrint(v, '', '', '')\n        return btoa(v)\n    },\n    base64d(v) {\n        if (typeof v != 'string')\n            throw 'can only base64-decode strings'\n        return atob(v)\n    },\n    sh(v) {\n        let t = nameType(v)\n        if (t == 'string')\n            return \"'\" + t.replace(/'/g, \"'\\\\''\") + \"'\"\n        else if (t == 'number')\n            return '' + v\n        else if (t == 'boolean')\n            return '' + v\n        else if (v === null)\n            return 'null'\n        else if (t === 'array') {\n            return v.map(v => {\n                let t = nameType(v)\n                if (t == 'string')\n                    return \"'\" + v.replace(/'/g, \"'\\\\''\") + \"'\"\n                else if (t == 'number')\n                    return '' + v\n                else if (t == 'boolean')\n                    return '' + v\n                else if (v === null)\n                    return 'null'\n                else\n                    throw t + ' cannot be escaped for shell'\n            }).join(' ')\n        } else\n            throw t + ' cannot be escaped for shell'\n    },\n}\n\nconst functions = {\n    'tostring/0': function*(input) {\n        yield formats.text(input)\n    },\n    'empty/0': function*(input) {\n    },\n    'path/1': Object.assign(function*(input, conf, args) {\n        let f = args[0]\n        yield* f.paths(input, conf)\n    }, {params: [{mode: 'defer'}]}),\n    'select/1': Object.assign(function*(input, conf, args) {\n        let selector = args[0]\n        for (let b of selector.apply(input, conf))\n            if (b !== false && b !== null)\n                yield input\n    }, {\n        params: [{label: 'predicate', mode: 'eval'}]\n    }),\n    'select/1-paths': function*(input, conf, args) {\n        let selector = args[0]\n        for (let b of selector.apply(input, conf))\n            if (b !== false && b !== null)\n                yield []\n    },\n    'length/0': function*(input) {\n        let t = nameType(input)\n        if (t == 'string' || t == 'array')\n            return yield input.length\n        if (t == 'null') return yield 0\n        if (t == 'object') return yield Object.keys(input).length\n        throw 'cannot compute length of ' + t\n    },\n    'keys/0': function*(input) {\n        yield* Object.keys(input).sort()\n    },\n    'has/1': Object.assign(function*(input, conf, args) {\n        let f = args[0]\n        for (let k of f.apply(input, conf))\n            yield input.hasOwnProperty(k)\n    }, {params: [{label: 'key'}]}),\n    'has/1-paths': function*(input, conf, args) {\n        let f = args[0]\n        for (let k of f.apply(input, conf))\n            if (input.hasOwnProperty(k)) yield []\n    },\n    'in/1': Object.assign(function*(input, conf, args) {\n        let f = args[0]\n        for (let o of f.apply(input, conf))\n            yield o.hasOwnProperty(input)\n    }, {params: [{label: 'object'}]}),\n    'in/1-paths': function*(input, conf, args) {\n        let f = args[0]\n        for (let o of f.apply(input, conf))\n            if (o.hasOwnProperty(input)) yield []\n    },\n    'contains/1': Object.assign(function*(input, conf, args) {\n        let f = args[0]\n        let t = nameType(input)\n        for (let o of f.apply(input, conf)) {\n            let ot = nameType(o)\n            if (t != ot) {\n                throw t + ' and ' + ot + ' cannot have their containment checked'\n            } else\n                yield containsHelper(input, o)\n        }\n    }, {params: [{label: 'element'}]}),\n    'inside/1': Object.assign(function*(input, conf, args) {\n        let f = args[0]\n        let t = nameType(input)\n        for (let o of f.apply(input, conf)) {\n            let ot = nameType(o)\n            if (t != ot) {\n                throw t + ' and ' + ot + ' cannot have their containment checked'\n            } else\n                yield containsHelper(o, input)\n        }\n    }, {params: [{label: 'container'}]}),\n    'to_entries/0': function*(input, conf) {\n        let t = nameType(input)\n        if (t == 'array') {\n            let ret = []\n            for (let i = 0; i < input.length; i++)\n                ret.push({key: i, value: input[i]})\n            yield ret\n        } else if (t == 'object')\n            yield Object.entries(input).map(a => ({key: a[0], value: a[1]}))\n        else\n            throw 'cannot make entries from ' + t\n    },\n    'from_entries/0': function*(input, conf) {\n        let t = nameType(input)\n        if (t == 'array') {\n            let obj = {}\n            for (let {key, value} of input)\n                obj[key] = value\n            yield obj\n        } else\n            throw 'cannot use entries from ' + t\n    },\n    'type/0': function*(input) {\n        yield nameType(input)\n    },\n    'range/1': Object.assign(function*(input, conf, args) {\n        for (let m of args[0].apply(input, conf))\n            for (let i = 0; i < m; i++)\n                yield i\n    }, {params: [{mode: 'defer'}]}),\n    'range/2': function*(input, conf, args) {\n        for (let min of args[0].apply(input, conf))\n            for (let max of args[1].apply(input, conf))\n                for (let i = min; i < max; i++)\n                    yield i\n    },\n    'range/3': function*(input, conf, args) {\n        for (let min of args[0].apply(input, conf))\n            for (let max of args[1].apply(input, conf))\n                for (let step of args[2].apply(input, conf))\n                    for (let i = min; i < max; i+=step)\n                        yield i\n    },\n    'any/0': function*(input, conf) {\n        if (nameType(input) != 'array')\n            throw 'any/0 requires array as input, not ' + nameType(input)\n        for (let b of input)\n            if (b) return yield true\n        yield false\n    },\n    'any/1': Object.assign(function*(input, conf, args) {\n        if (nameType(input) != 'array')\n            throw 'any/1 requires array as input, not ' + nameType(input)\n        for (let v of input)\n            for (let b of args[0].apply(v, conf))\n                if (b) return yield true\n        yield false\n    }, {params: [{mode: 'defer'}]}),\n    'any/2': function*(input, conf, args) {\n        let gen = args[0]\n        let cond = args[1]\n        for (let v of gen.apply(input, conf))\n            for (let b of cond.apply(v, conf))\n                if (b) return yield true\n        yield false\n    },\n    'all/0': function*(input, conf) {\n        if (nameType(input) != 'array')\n            throw 'all/0 requires array as input, not ' + nameType(input)\n        for (let b of input)\n            if (!b) return yield false\n        yield true\n    },\n    'all/1': Object.assign(function*(input, conf, args) {\n        if (nameType(input) != 'array')\n            throw 'all/1 requires array as input, not ' + nameType(input)\n        for (let v of input)\n            for (let b of args[0].apply(v, conf))\n                if (!b) return yield false\n        yield true\n    }, {params: [{mode: 'defer'}]}),\n    'all/2': function*(input, conf, args) {\n        let gen = args[0]\n        let cond = args[1]\n        for (let v of gen.apply(input, conf))\n            for (let b of cond.apply(v, conf))\n                if (!b) return yield false\n        yield true\n    },\n    'add/0': function*(input, conf) {\n        if (nameType(input) != 'array')\n            throw 'can only add up arrays'\n        if (input.length == 0) return yield null\n        if (input.length == 1) return yield input[0]\n        let ret = AdditionOperator.prototype.combine(input[0], input[1],\n            nameType(input[0]), nameType(input[1]))\n        for (let i = 2; i < input.length; i++)\n            ret = AdditionOperator.prototype.combine(ret, input[i],\n                nameType(ret), nameType(input[i]))\n        yield ret\n    },\n    'tonumber/0': function*(input) {\n        yield Number.parseFloat(input)\n    },\n    'reverse/0': function*(input) {\n        if (nameType(input) != 'array')\n            throw 'can only reverse arrays, not ' + nameType(input)\n        yield input.toReversed()\n    },\n    'sort/0': function*(input, conf) {\n        if (nameType(input) != 'array')\n            throw 'can only sort arrays, not ' + nameType(input)\n        let r = Array.from(input)\n        yield r.sort(compareValues)\n    },\n    'sort_by/1': Object.assign(function*(input, conf, args) {\n        if (nameType(input) != 'array')\n            throw 'can only sort arrays, not ' + nameType(input)\n        let key = args[0]\n        let r = input.map(v => ({\n            key: key.apply(v, conf).next().value,\n            value: v\n        }))\n        r.sort((a, b) => compareValues(a.key, b.key))\n        yield r.map(a => a.value)\n    }, {params: [{mode: 'defer'}]}),\n    'explode/0': function*(input, conf) {\n        if (nameType(input) != 'string')\n            throw 'can only explode string, not ' + nameType(input)\n        let ret = []\n        for (let i = 0; i < input.length; i++) {\n            let c = input.charCodeAt(i)\n            ret.push(c)\n            if (c > 0xffff)\n                i++\n        }\n        yield ret\n    },\n    'implode/0': function*(input, conf) {\n        if (nameType(input) != 'array')\n            throw 'can only implode array, not ' + nameType(input)\n        yield input.map(x => String.fromCodePoint(x)).join('')\n    },\n    'split/1': Object.assign(function*(input, conf, args) {\n        if (nameType(input) != 'string')\n            throw 'can only split string, not ' + nameType(input)\n        for (let s of args[0].apply(input, conf)) {\n            yield input.split(s)\n        }\n    }, {params: [{label: 'separator'}]}),\n    'join/1': Object.assign(function*(input, conf, args) {\n        if (nameType(input) != 'array')\n            throw 'can only join array, not ' + nameType(input)\n        let a = input.map(x => {\n            if (typeof x == 'number') return '' + x\n            if (typeof x == 'string') return x\n            if (typeof x == 'boolean') return '' + x\n            if (x === null) return ''\n            throw 'cannot join ' + nameType(x)\n        })\n        for (let s of args[0].apply(input, conf))\n            yield a.join(s)\n    }, {params: [{label: 'delimiter'}]}),\n}\n\n// Implements the containment algorithm, returning whether haystack\n// contains needle:\n// * Strings are contained if they are substrings\n// * Arrays if each element is contained in some element of other\n// * Object if values contained by values in matching key\n// * All others, if they are equal.\n// This helper function is necessary because the recursive case\n// has different error behaviour to the user-exposed function.\nfunction containsHelper(haystack, needle) {\n    let haystackType = nameType(haystack)\n    let needleType = nameType(needle)\n    if (haystackType != needleType) {\n        return false\n    } else if (haystackType == 'string') {\n        return (haystack.indexOf(needle) != -1)\n    } else if (haystackType == 'array') {\n        for (let b of needle) {\n            let found = false\n            for (let a of haystack) {\n                if (containsHelper(a, b)) {\n                    found = true\n                    break\n                }\n            }\n            if (!found)\n                return false\n        }\n        return true\n    } else if (haystackType == 'object') {\n        for (let k of Object.keys(needle)) {\n            if (!haystack.hasOwnProperty(k))\n                return false\n            if (!containsHelper(haystack[k], needle[k]))\n                return false\n        }\n        return true\n    } else {\n        return haystack === needle\n    }\n}\n\ndefineShorthandFunction('map', 'f', '[.[] | f]')\ndefineShorthandFunction('map_values', 'f', '.[] |= f')\ndefineShorthandFunction('del', 'p', 'p |= empty')\ndefineShorthandFunction('with_entries', 'w', 'to_entries | map(w) | from_entries')\ndefineShorthandFunction('arrays', '', 'select(type == \"array\")')\ndefineShorthandFunction('objects', '', 'select(type == \"object\")')\ndefineShorthandFunction('booleans', '', 'select(type == \"boolean\")')\ndefineShorthandFunction('strings', '', 'select(type == \"string\")')\ndefineShorthandFunction('numbers', '', 'select(type == \"number\")')\ndefineShorthandFunction('nulls', '', 'select(type == \"null\")')\n\nconst jq = {compile, prettyPrint}\n// Delete these two lines for a non-module version (CORS-safe)\nexport { compile, prettyPrint, compileNode, formats }\nexport default jq\n","import jq from './jq.js'\n\nexport function resolve(input) {\n    return new JsonVariableResolver().resolve(input);\n}\n\nclass JsonVariableResolver {\n    constructor() {\n        this.pathHistory = new Map(); // \n        this.unresolvedCount = 0\n        this.resolvedCount = 0\n    }\n\n    /**\n     * Resolve variables in a JSON object.\n     * @param {Object} json - The input JSON object with potential variable references.\n     * @returns {Object} - A new JSON object with resolved variable references.\n     * @throws {Error} - Throws an error if circular references are detected.\n     */\n    resolve(json) {\n        const result = JSON.parse(JSON.stringify(json)); //  JSON\n\n        while (!this.resolveAll(result)) {\n        }\n        return result;\n    }\n\n    /**\n     * Resolve all variables in the JSON object.\n     * @param {Object} root - The root object being processed.\n     * @returns {boolean} - The count of unresolved variables after the current pass.\n     */\n    resolveAll(root) {\n        this.unresolvedCount = 0;\n        this.resolvedCount = 0;\n        let varList = this.traverse(root);\n        this.checkAndResolve(root, varList)\n        if (this.resolvedCount !== 0) {\n            return false\n        }\n        if (this.unresolvedCount === 0) {\n            return true\n        }\n        if (this.unresolvedCount > 0) {\n            let path = [...new Set(varList.map(v => v.originalValue))].sort().join(\", \")\n            const errorMessage = `Circular reference exists or variable not resolvable: ${path}`;\n            console.log(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n\n    /**\n     * Traverse the JSON object and resolve variables if possible.\n     * @param {Object} currentObject - The current object being processed.\n     * @return\n     */\n    traverse(currentObject) {\n        const variablesToResolve = [];\n        const currentPath = []\n\n        const collectVariables = (obj, path) => {\n            for (const key in obj) {\n                const value = obj[key];\n                const newPath = [...path, key];\n\n                if (typeof value != \"string\") {\n                    collectVariables(value, newPath);\n                } else {\n                    const match = value.match(/^\\${(.+)}$/);\n                    if (match) {\n                        variablesToResolve.push({\n                            path: newPath,\n                            parent: obj,\n                            variablePath: match[1],\n                            originalValue: value\n                        });\n                    }\n                }\n            }\n        };\n        collectVariables(currentObject, currentPath);\n        return variablesToResolve\n    }\n\n    checkAndResolve(root, variablesToResolve) {\n        for (const variable of variablesToResolve) {\n            const resolvedValue = this.getValueFromPath(root, variable.variablePath);\n\n            if (resolvedValue === undefined) {\n                this.unresolvedCount++;\n                continue;\n            }\n\n            if (this.checkAndRecordCircularReference(variable.path, variable.variablePath)) {\n                let path = [...new Set(variablesToResolve.map(v => v.originalValue))].sort().join(\", \")\n                const errorMessage = `Circular reference detected, variable: ${path}`;\n                console.log(errorMessage);\n                throw new Error(errorMessage);\n            }\n\n            let parentObj = variable.parent;\n            parentObj[variable.path[variable.path.length - 1]] = JSON.parse(JSON.stringify(resolvedValue));\n            this.resolvedCount++;\n        }\n    }\n\n    /**\n     * Check if resolving the current path would cause a circular reference, and record it.\n     * @param {Array<string>} currentPath - The current path being resolved.\n     * @param {string} variablePath - The path of the variable being replaced.\n     * @returns {boolean} - True if a circular reference would be created, false otherwise.\n     */\n    checkAndRecordCircularReference(currentPath, variablePath) {\n        for (let i = 1; i <= currentPath.length; i++) {\n            const parentPath = currentPath.slice(0, i).join('.');\n            if (this.pathHistory.get(parentPath) === variablePath) {\n                return true; // \n            }\n        }\n\n        const pathStr = currentPath.join('.');\n        this.pathHistory.set(pathStr, variablePath);\n        return false; // \n    }\n\n\n    /**\n     * Retrieve the value from the JSON object using a dot-separated path.\n     * @param {Object} object - The JSON object.\n     * @param {string} path - The dot-separated path to the desired value.\n     * @returns {*} - The value at the specified path, or undefined if not found.\n     * @throws {Error} - Throws an error if array index is out of bounds.\n     */\n    getValueFromPath(object, path) {\n        let filter = jq.compile(path)\n\n        let outputStr = ''\n        try {\n            for (let i of filter(object)) {\n                if (typeof i == 'undefined') {\n                    return undefined\n                } else {\n                    outputStr += jq.prettyPrint(i) + '\\n'\n                }\n            }\n            return JSON.parse(outputStr)\n        } catch (e) {\n            return undefined\n        }\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as jvr from \"./json_var_resolver.js\";\n\n// Utility function to merge default config with user config\nfunction mergeConfig(userConfig, defaultConfig) {\n    return userConfig || defaultConfig;\n}\n\n// Load the configuration from Chrome's storage or fallback to the default configuration\nasync function loadConfig() {\n    try {\n        const userConfig = await chrome.storage.sync.get(['userConfig']);\n        const defaultCfg = await chrome.storage.session.get(['defaultCfg']);\n        document.getElementById('config-input').value = userConfig.userConfig || defaultCfg.defaultCfg;\n    } catch (error) {\n        console.error(\"Failed to load configuration:\", error);\n    }\n}\n\n// Save the user configuration to Chrome's storage\nasync function saveConfig() {\n    try {\n        var userConfig = document.getElementById('config-input').value;\n        const userConfigObj = JSON.parse(userConfig);\n        jvr.resolve(userConfigObj);\n        await chrome.storage.sync.set({ userConfig });\n        alert('Configuration saved successfully!');\n    } catch (e) {\n        alert('Invalid JSON format. Please check your configuration.');\n    }\n}\n\n// Reset the configuration to the default value\nasync function resetConfig() {\n    if (confirm('Are you sure you want to reset to the default configuration?')) {\n        try {\n            const defaultCfg = await chrome.storage.session.get(['defaultCfg']);\n            await chrome.storage.sync.set({ userConfig: defaultCfg.defaultCfg });\n            loadConfig();  // Ensure the default config is loaded after reset\n            alert('Configuration reset to default.');\n        } catch (error) {\n            console.error(\"Failed to reset configuration:\", error);\n        }\n    }\n}\n\n// Event listeners for buttons\ndocument.getElementById('save-config').addEventListener('click', saveConfig);\ndocument.getElementById('reset-config').addEventListener('click', resetConfig);\n\n// Load the config when the page loads\nwindow.onload = loadConfig;\n"],"names":[],"sourceRoot":""}